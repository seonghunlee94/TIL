# Java spec



### J2SE

기본 기술 : java, jdbc 이 두 가지 기술 셋은 jdk가 설치되어야 쓸 수 있다.



##### JAVA

하드웨어 위에 OS 탑재되어 있는데, jdk는 os 위에 올라간다. 정확하게 말하면 os 위에 자바 실행환경이 만들어지는 것이다. 자바 실행환경(JRE)에는 JVM 자바 가상 기계(즉 메모리)가 들어있다. 프로그램은 jvm 안에서 돌아간다고 말할 수 있다. 여기까지 배우는게 java다.



##### JDBC 

데이터 베이스 안에 데이터를 저장하고 그 데이터 구조는 이천구조(?)로 저장된다.

데이터는 컬럼과 로우(행과 열 구조)로 저장



공통점 : J2SE 사용

차이점 : 서버(로컬 서버와 DB 서버)



로컬 머신은 1tier이고 DB는 2tier라서 connectivity가 필요하다. 연결과 통신은 jdbc로 한다.





### J2EE

J2EE : enterprize -> servelet, jsp , spring framework 즉 웹 기술은 j2ee로 사용되는 것이다.

JDK + WebApplication Server(WAS) 두 개 탑재되어 있어야 엔터프라이즈 기술을 사용 가능하다.





# 자바 구조

platform 플랫폼? program이 구동(실행)하는 곳.

원시 소스코드 -> 인간이 알아보는 코드, 기계 X

그래서 반드시 기계어로 바꿔줘야 하는데, 그 과정을 컴파일 과정이라고 말한다.

이 컴파일 과정은 문법을 쓴 후, 저장할 때 이루어진다. 컴파일이 되려면 문법적으로 오류가 없어야 한다.

컴파일 과정 후에는 실행파일 (.class)이 만들어진다. 실행 파일은 JVM에서 실행된다. 그래서 어떤 하드웨어든지 운영체제든지 돌아갈 수 있다.

자바는 컴파일과 실행 두 가지로 이루어진다. 실행파일은 byte code로 jvm과 연결되어 byte code로 돌아간다.

실행 파일이 돌아가는 장소를 platform이라고 하는데, 자바는 platform의 독립적이다. 그리고 자바를 실행하는 JVM은 os에 종속적이다.





자바 홈은 Progarm Files -> java

모든 소프트웨어 툴은 bin 폴더 안에 소프트웨어 실행과 stop 관련 파일을 넣는다.

java.exe은 실행하고, javac.exe은 컴파일한다. 컴파일은 소스코드를 기계어로 바꾸어주는 것이다.

자바는 컴파일 과정을 하지만, 완벽한 기계어로 바뀌지 않는다. 완벽한 기계어는 바이너리 코드로 바뀐다는 의미이다. 그래서 자바의 실행 파일은 byte code 이기 때문에 실행이 바로 되지 않는다. 그래서 jvm에서 byte code가 실행되야 한다. 이렇게 두 번의 과정을 거쳐야 하는 이유는 플랫폼에서 독립적이게 만들었기 때문이다.







자바 실행 환경(JRE)은 lib 라이브러리다. 

rt.jar를 들어가면, java->javax 라이브러리를 볼 수 있다.

java'x' => Extension 확장이다. java extension이다.

실행한다는 의미는 "메모리를 탄다"라는 의미다.



rt.jar는 이미 만들어놓은 클래스(실행파일)을 활용할 수 있다. 즉, API 또는 라이브러리라고 부른다.



하드웨어랑 밀착된 코드를 작성하기 위해서는 c가 사용되어야 되고

자바는 jvm으로 돌리기 때문에 바이너리 코드로까지 변환 안한다.

class 실행파일을 알고 싶을 때 src.zip 압축을 풀면 원시코드로 볼 수 있다.



OOP 객체지향은 컴파일 대상만 가능, 실행 대상X





String -> class Data type : 대문자로 시작

int -> 예약어(기본형) : 소문자 => 고정되어 사용(데이터 타입 제한)





클래스 1) 실행클래스, 2) OOP 대상()

실행클래스 => 객체를 생성 == 멤버 메모리에 올린다.

​                    => 멤버에 올라간 객체에 접근한다.



멤버 1) 변수 2) 메소드

변수 == 값할당

메소드 == 호출





JVM : 자바가 어떻게 돌아가는지

해석, 실행되는 순서

1. class 파일이 메모리에 load 됨
2. 로드된 후 실행이 이루어짐 -> jvm이 제일 먼저 main을 찾는다. main이 있으면 실행을 하고 없으면 실행을 안한다. "Start - main"
3. main 밑에 메소드 부분 실행? 객체 생성 == 메모리에 올라간다. 참조변수로 {(ex 참조변수-> nb) NoteBook **nb** = new NoteBook();
4. 참조변수로 불러오고, 값을 공간(변수)로 넣어준다.
5. 메소드 호출을 하고, worker 메소드 안에 기능들을 수행한다.
6. 그 후 콜백해 밑에 있는 코드를 수행하거나 없을 시 메모리에서 내린다.

