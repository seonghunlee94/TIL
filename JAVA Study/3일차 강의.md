# OOP의 3대 특징



1. Encapsulation
2. imheritance
3. polymorphism



Has a Relation? 

어제 만든 것 

NoteBook - program - Test 

객체를 생성한다 = 메모리에 올린다 = 값 세팅(how? 펑션을 통해 올린다.)

필드가 중요한 이유는? 값을 넣는 공간이기에 프로젝트 방향이 설정된다.



값 넣어주는 두 가지 방법

1) 명시생성자
2) set~()

오늘 수업에서는 노트북 클래스하고 프로그램 클래스가 아직 관계가 없는데, Test랑 관계가 있다. 근데 여기서 Test를 제외했을 때, OOP() 추출단계다. 여기에 관계를 넣어줄 수 있는데, 상속(수직) 또는 Has a Relation(수평) 두가지다. 오브젝트 관계를 추출하는게 중요해. 왜냐하면 여기서 Test를 제외할 거야, 오브젝트가 많아지겠지? {오브젝트 추출단계랑 독립변수(x, feature = 필드와 유사) 서로 비슷해.(?)} 필드들끼리 연관성이 맺어져야지만 해.

그렇다면 연관을 어떻게 지울까? 1) 노트북과 프로그래머를 Has a 관계를 설정해! 그러기 위해서 먼저 필드에 Notebook을 추가하고, notebook 필드를 주입해야돼(how? 명시적 생성자, setter).

-notebook의 필드 전체 추가 --> 중요한 거 NoteBook noteBook = new NoteBook(); 가장 중요한 법칙은 가져오려는 클래스의 앞문자만 소문자로 넣어주기. 심플 스펙스피(?)한게 중요! 아직 주입한거는 아니야

-notebook을 아예 주입(명시적 생성자 or setter)

여기서 중요한 거는 문법보다 생각 전략 구현해 내려는 아이디어가 있어야 한다. 생각하면서 작업해야돼

생각하고 이해하면서 작업해야 늘어!!! 프로그램이 무엇인지 빠르게 이해하는게 중요해!!

setNoteBook -> buyNoteBook ,

setter 이 두 줄의 코드를 추가한게 엄청난거야 -> ProgrammerTest의 변화를 비교해보기!



```
		Programmer james=new Programmer("james", "NY","JAVA", 3500 );
		//james가 노트북을 구매... has a relation
        james.buyNoteBook(new NoteBook("SAMSUNG", 200, 1234));
```



buyBoteBook 이전으로 james는 노트북 소유 X 

11라인에서 노트북을 가진 james가 됨

james가 구매한 노트북 정보를 가져오려면 Programmer에서 가져오는 메소드를 만들어줘야 한다. 

Programmer가 NoteBook 클래스의 has a 관계여서 연결해서 printInfo를 출력할 수 있다.







# 언어 추세?

파이썬 기반           -----   java Base                ----node(프론트 대세 기술 react, vue.js)

#### 파이썬 

Django, flask, python(파이썬은 일종의 도구) 모든 AI는 파이썬으로 만들어져서 중요해!

프로그램 쪽으로는 달라. 파이썬을 배웠다는 것은 데이터 분석을 위해서 도구를 사용했다는 의미여서 코드를 배웠다는 거랑 달라. (도구로 이용, 프로그램으로 보는 것보다 도구로 봐)-깊게 들어가면 어려워, 안되는게 없게 만들어졌기 때문이야. 깊이 다루면 되게 무거운 언어야!!

파이썬으로 분석하게 만들면 호환가능해 (R은 호환 안되거든)

#### JavaBase 

가장 많이 쓰는 도구는 Eclipse야!! 반면 프론트 쪽이나 파이썬으로 AI, 데이터 분석은 vs code로 많이 써! 자바 역시 vs code를 많이 쓰고!!



크게 vs code랑 eclipse를 사용하는데! 이런 툴을 IDE(Integrated Development Environment)라고 불러.

툴은 자동완성으로 쓸 수 있게 만들어져 있어. 프로그램에서 가장 중요한 거는 필드야! 그 다음 순차적으로 뭐를 해야돼? 값 주입하는 펑션과 값 돌려받는 평션을 만들어야 돼!! 생성자!



생성자랑 set, get으로 받고 주고 하고, 혹시 더 추가적인 상황은 추가적으로 메소드 만들어주면 돼!!

```

		//1.고객을 생성
		Customer custom = new Customer("James", "Gpsling");
		
		//2. James가 통장을 하나 개설 ... Has a Relation
		custom.setAccount(new Account(10000.0));
		
		//3.James가 개설한 통장을 하나 받아서...
		//Customer클래스에 있는 getAccount()메소드를 호출...  .은 at이야!
		Account jamesAcc=custom.getAccount();
```

아직 has a 관계가 아닌 이유(표현 중요)  : 필드에 선언이 안됐고, 주입이 안되었다.

고객이 통장을 주입받아야 한다.(3)



필드로 설정한 거가 자동완성할 때 그 이름으로 set get이 만들어져! 그니까 중요해! 함수가 뭔지 알아볼 수 있어야지!

값 주입 = 인스턴스(??)







# Operator (연산자) 



프로젝트 안은 클래스로 이루어져 있다.





# Scanner

실행 시 코드에 값을 직접 입력받는 것이 아니라
	new Account(10000); <- 코드에 입력, 시점? 1.컴파일(0) 2. 실행(X)
	-- 컴파일 시점에 값이 하드코딩되어져 있다..)
	근데 프로그램은 실행시 값이 입력받아야돼
	실행할 때마다 서로 다른 값이 입력할 수 있어야 한다는 의미야!
	웹을 하면 값을 받기 위해, 화면에 클릭시 받게 설정해. 
	클라이언트가 클릭하면, 서버로 값이 전달돼! 값을 실행할 때 받을 수 있도록 만들어줘야해!
	-- 실행 시점에서 값을 입력받을 수 있도록 할 때 필요한 클래스가  scanner

```
		System.out.println("키보드로 숫자를 입력하세요>>>>>");
		//1. Scanner 객체를 생성.. 메모리에 올린다.
		Scanner sc=new Scanner(System.in); 
		
		//2. Scanner의 기능을 이용해서 값을 받아옴..
		int i=sc.nextInt();//키보드를 친 것을 얘가 받아와
		int j= sc.nextInt();//nextInt는 공백을 기준으로 데이터를 반환
		
		String name =sc.next();//문자를 입력하는 것은 그냥 next를 하면돼!
		
		System.out.println("숫자값 : "+i+","+j);
		System.err.println("당신의 이름은"+name);
```







패키지는 디렉토리랑 같은 의미!





# Condition(조건문)



제어문(조건문) : 특정한 상황에서만 코드가 실행되도록 제어하는 문장(정의) 

다른 전문가들은 "조건이 참일 때만 코드블락"{""}을 실행

코드블락 ={ " "   }  

if(조건) / else if(조건)/ else 

if(i==0){ " "}



```
if(x == y) system.out.println(" "); //{} 생략 가능
```

Statement가 한 줄일 때 { } 생략 가능



조건문 

- if

- switch

  - switch(변수) -> 변수 타입은 숫자, 문자, 문자열 가능, 실수형은 못들어옴
    {

    case 1:
    case 6: 이런 케이스일 때만 코드블락을 적으면 되고 그 후 break;

    }

  - 스위치 문장은 특별한 상황을 통제하는 문장이지만, 범위를 설정하는 문장은 아니다.

  - 상황별로 직접 코치할 때 switch를 많이 쓴다.

  - case를 따라서 문장의 상황을 제어할 때

    

 switch의 대표적인 특징, break가 빠졌는데 그 이유는, break는 case뿐만 아니라 switch도 빠져나간다. 시작한 부분부터 끝까지 동작해야 되는 경우, break를 쓰지 않는다.

if를 사용할 때 : 범위를 포함한 조건문을 사용할 때



# 프로그램 ?? 

입력된 값에 따라 결과값이 달라지는 (예측 가능한) 알고리즘

어떤 언어로, 어떤 패턴으로 개발하는가 중요.

머신 러닝 : 인간은 개입X, 엄청난 양의 데이터를 줘야함, 그 패턴을 기계가 학습함

머신이 어떤 값을 도출하는지 모르지만, 꽤 정확한 값을 출력해줌

프로그램은 인간이 만들었기에 명료해 예측 가능한 알고리즘이야.

차이점 : 머신 러닝은 예상하지 못하지만 꽤 정확하고, 프로그램은 예측 가능한 알고리즘이다.





# Math



abs 절대값.(양수든 음수든 값을 똑같이 파악)

Random() 0~ 1(보다 작은) 사이의 실수를 랜덤으로 뱉어냄. 

static이 붙은 맴버들은 메모리에 안올리고 바로 써도 돼!! 바로 가져다 쓸 수 있음!!
static은 이미 메모리에 올라가져 있기 때문에 객체 생성을 건너 띌 수 있음!



# Encapsulation 캡슐화하다. 

보호할 때 캡슐을 씌운다. 무엇을 보호하려는 것일까?



프로그램에서 가장 중요한 것은 필드다. 설계할 때 중요. 필드는 공간, 목적은 얼마나 정확한 값을 넣는지이다. 그런데 지금 다른 클래스에서 잘못된 값을 넣어버릴 때가 있을 수 있다. 이것을 직접적인 접근이라고 부른다. 매우 무례한 짓이야. 필드에 바로 값을 꽃는 것은 눈 뜨고 찾아볼 수 없는 짓이다.

프로그램이 고차원적으로 갈 때 치명적인 실수를 할 수 있는 루트가 직접적인 접근에서 나온다.

그래서 나온게 캡슐화가 나온 것이다!!!



클래스에서 가장 중요한 것은 Date(필드)다. 필드에 입력한 값을 Date라고 한다.

외부에서 함부로 접근해서 가장 중요한 필드에 인밸리드한 값을 꽂는 것을 막기 위해서 접근 못하도록 캡슐을 씌어야 한다. 캡슐을 씌우면 데이터는 보호가 되는데, 필요할 때 접근할 수가 없는 문제가 생긴다. 그래서 외부에서 접근할 수 있도록 개구멍을 뚫는다. set메소드(값을 받아오고)와 get(값을 전달하는)메소드를 통해 접근 가능하다.

캡슐화는 field 값을 보호하기 위해서 씌운다. 

1) 외부(다른 클래스)로부터 직접적으로 막는다. private
2) Field 값을 set geet으로 소통함, public은 접근 지정자
3)  중요? 무엇일까?

































































