엔터프라이즈 기술은 서버에서 돌리는 기술이다. 서블릿과 JSP가 사용되는데, 서블릿 엄청 중요!  

서버를 (나온다는)사용한다는 것은 ui가 나온다는 의미이기에 프론트 엔드 기술도 알아야 한다.



현업에서는 Spring Framework를 사용하는데, 먼저 자바를 알아야 한다. 그 중 OOP, java+ DB, servlet을 잘 알아야 한다!!***



(화요일 수업 복습 및 설명)노트북 클래스가 만들어진 구조 살펴보기

NoteBook 맴버 3개 brandName, price , printInfo()로 구성

Field / Method 설명

Field는 변수 중에서도 맴버 변수이다. 

(2)필드와 (1)메소드는 클래스의 구성요소다.

클래스 구성 요소 = 필드 + 메소드

필드 선언부는 데이터 타입 + 필드명으로 선언한다. ex) String(데이터 타입) brandName(필드명);

필드는 선언되는 위치가 엄청 중요하다. 클래스 선언 바로 아래(메소드 구역은 중괄호 밖에) 선언되어야 한다. 필드를 선언할 때는 반드시 데이터 타입이 와야하고, ';'로 종결되어야 된다.

메소드 선언문은 "public ~ 메소드 이름()"까지 이고, {} 안은 메소드 구현부이다. 여기에서 기능이 정의되어 있다.

return type => 반환타입 , 되돌와오는 값이 있는가 없는가?

void = 반환값이 없을 때 사용하는 키워드

sysout은 출력을 하지, 되돌리는 값이 있는게 아니야, 반환 값이 있는 경우는 어떻게 할까? void 사용하지 말고 다른 거 사용하자.

메소드 () 안에 인자값을 넣을 수 있다.







자바 프로젝트는 클래스로 시작해.





메소드 구현부가 있는 메소드를 worker 메소드라고 부른다.

콜링을 하면 워킹 메소드가 구현된다. 메소드 정의는 메소드 선언부와 메소드 구현부를 합친 것을 말한다.



메소드 이름은 반드시 아이덴티파이로 지어야 한다. 이것을 잘 써야지만, 구현이 어떻게 되는지 쉽게 알수 있다. 코드 가독성이 높아지고, 수정 보완이 용의하다. 이름을 잘 짓는 것은 기본이다. 

리턴 타입이 있을 때, 메소드 구현부 안에 return을 적어야 하고 그 뒤에 반환하는 값을 적어줘야 한다.



자바는 가장 먼저 찾는 지점은 main이다. 왜냐하면 JVM에서 실행하려면 무조건 main을 찾기 때문이다.

필드에 접근한다는 것은 값 할당이 이루어졌다는것이다. 



메소드가 호출되면 워커를 찾아간다. 그 후 메소드 구현부에서 기능을 실행한다. 그 후 다시 돌아가서 밑에 있는 코드를 동작시킨다. 

만약 호출을 했을 때 메소드 정의에서 리턴 값이 있다면, 호출한 곳으로 리턴이 되어진다. 

sysout (nb.getBrandName());을 사용해서 출력시킬 수 있다.

다시 말해 calling과 worker 사이를 왔다갔다 하는 것이다.



공간의 값이 바뀔 때 오버라이딩 된다. 하나의 공간에는 하나의 값이 저장되기 때문이다. 





클래스를 두 개 이상 돌리려고 할 때, 실행 클래스를 가져오려면, 상위 패키지부터 하위 패키지까지 잘 입력해줘야 한다. 그 이유는 연결시지지 않으면 에러가 난다.

어디 클래스에서 어디 클래스로 연결하려는 거니? == 어디 클래스에서 어디 클래스를 생성하려는 거니?

근데 만약 다른 패키지에 있는 클래스를 생성하려고 하는데 import를 안하면 에러난다. 

JVM이 main을 찾고. 현재 디렉토리(패키지)에서 맴버를 찾는다. 그래서 어디에서 가져와야 하는지 알려줘야 한다.





필드값이 너무 많아지지 않도록 하기 위해서

메소드에 인자값을 통해서 필드값을 넣어줄 수 있다. 

메소드를 호출하면서 인자값에 넣어줄 변수명과 필드명을 맞쳐 넣어주면 코드가 줄어든다.



데이터 타입 뒤에 변수명 (인자값)으로 들어가는 변수명은 field인가? 아니다. 맴버 변수가 아니다. 그 이유는

선언된 위치가 메소드 영역 안이기 때문이다. 이런 변수는 local 변수 또는 지역 변수라고 부른다. 







variable은 필드와 로컬 변수가 있다. 

필드는 클래스의 맴버 즉 구성 요소다. 위치는 클래스 선언 아래, 메소드 영역 바깥이다.

선언만 해도 기본 값을 가지고 있다. 타입에 따라 기본값이 설정되어 있다.

필드를 맴버 변수라고 부르기도 한다. 그러나 자바에서 정확한 이름은 필드다.

로컬변수는 메소드 영역 안에 선언된다. 기본 값이 없다.





워커 메소드 = 메소드 정의 부분 -> 선언부에서 중요한 것은 리턴 타입과 아퀴먼트 부분이다.

구현부에서는 어떤 일을 하는지 알 수 있다. 

실행 클래스에서 호출할 때 받아온 인자값으로 필드에 다시 값 할당



필드 초기화 -> 최초에 값을 넣는 것 X 새로운 값을 넣는 것이 초기화이다. 새로운 값 할당!



로컬변수 이름을 정확하게 할 시, 필드와 이름이 같아진다. 그러면 기계에서 알지 못하기에 this를 통해서 필드와 로컬변수의 이름을 구별한다. this는 참조한 레퍼런스 값을 받아온 것임을 알려준다. 

이 과정을 통해 로컬 변수 값(인자값이)이 다시 필드에 할당되는데, 필드 초기화라고 부른다.







워커 메소드의 순서는 중요하지 않다. 그 이유는 호출되어야만 동작하기 때문이다. 다시 말해 Test클래스의 호출 순서에 따라 워커 메소드가 동작하기 때문에 실행클래스 안에서 메소드 순서는 중요하지 않다는 말이다.







# class 구성요소



메소드와 필드를 문법적으로 설명

필드는 선언 위치와 기본값 유무를 정확히 이해 필요

메소드는 이름 짓는 방법, 리턴 타입이 어떻게 호출 및 백 되는지, 아귀먼트, 워커 메소드와 콜링 메소드로 나뉜다. 콜링 순서가 중요하다.  콜링을 해야만 워커 메소드가 실행된다.





Data Type 간단히 정리 후  constructor넘어가 설명, constructor 되게 중요, 오늘은 기본적인 부분만 설명

Data Type 

나눠지는 근거 1) 어떤 종류의 데이터 값이냐 2) 메모리에 올라가는 용량이 얼마나 되는가 

->1) 숫자형, 문자형, 논리형 크게 세 가지로 나눠지는데, 그 다음 숫자는 정수, 실수로 나눠지고, 정수는 byte, short, int, long, 공간에 값을 넣을 때 값이 정수일 때 쓸 수 있는 네 가지, 실수는 float, double 두 개가 있음, 0.37 같은 소수를 지정하는 타입이다. 그런데 이렇게 여러개가 있을 때 디폴트 타입이 있다. 즉 꼭 찝지 않을 시 int, double이 초기값이다. 문자형은 하나의 문자를 의미한다. james 등은 문자형이 아니다. char로 쓰는데 ' 싱글 코테이션으로' 입력해야 한다. EX) 'a'  . 논리형은 boolean인데 true와 false로 나뉜다. 디폴트 타입은 false다.



그리고 데이터 값에 따른 기본 값이 있다. 이것을 Deforlt value라 부른다. 



8가지 기본형과 클래스 타입으로 나뉜다. 클래스 타입의 기본값은 무조건 null이다.

메모리에 올라가는 용량이 다르다.



패키지 명은 무조건 소문자로, 두 개의 문자가 붙어도 무조건 소문자! 이게 규칙이야!!



빠르게 짧은 코드를 작성할 때 클래스를 한 페이지에 여러개를 넣을 때

퍼블릭은 하나만 들어가야 하고, 그 퍼블릭 이름으로 저장해야 한다. 

그 퍼블릭만 메인을 갖고 있다.



키워드(예약어)는 붉은 글씨로 보인다.





Constructor(생성자)***

생성자가 무엇인지, 지금까지 한 코드를 생성자로 바꾸어보기.

프로그램에서 가장 중요한 것은 "필드를 무엇으로 정하는가"이다.





객체 생성 => 값 할당을 아직 안하더라도 디폴트 값이 들어가 있음

메모리에는 값이 없으면 올라갈 수 없다



생성자가 콜링되는 부분 

생성자란? 객체가 생성될 때마다 구동하는것! 때마다!! 

객체가 세 개 만들어졌다는 것은 생성자가 세 번 호출됐다는거다.

객체의 실체는 맴버다. 그 중 값이 보이는 맴버인 필드다.

사람을 만들 때마다 값을 할당해주는게 비효율적이기 때문에 생성자는

즉 명시적 생성자는 객체 생성과 동시에 값을 넣어주는 것이다.



명시적 생성자 / Person(String name){

 					this.name=name;

}



set Method public void SetPerson(String name){

​				this.name=name;

}

둘 다 하는 일 필드 초기화 차이점

명시적 생성자 -> 생성과 소멸을 같이 한다.(life sycle)

set Method -> 생성과 소멸을 같이 하지 않는 것(생성 후 나중에 값 할당, 시기가 다르다.)



수평(hasing : 소유관계, Has a Relation)과 수직(상속)































