메소드 선언부 :  이름이 같을 시 같은 메소드라 생각할 수 있다.

이름이 같이 쓰이면 에러 날 것 같은데 에러가 안난다.

지금 에러가 안나는 이유는 인자값이 다르기 때문에 안나는 것이다.



메소드 이름이 중요한 이유는 identifier(이름 짓는 방법)

메소드 이름을 보면 어떤 일을 하는지 직관적으로 알 수 있기 때문이다.

코드의 일관성과 가독성을 높일 수 있도록 너무 스펙스틱하게 만들지 않는게 중요하다.

인자값으로 고객을 찾고 있기 때문에 차이가 난다.

메소드 오버로딩이라고 한다. 이거 되게 중요해!!!

=== 서비스는 메소드가 쭉 있어.

identify가 너무 제각각이면 가독력을 저해하는 요인이 돼

큰 틀에서 같으면 메소드 이름 통일하고, 아귀먼트 리스트를 조금이라도 다르게 해야돼

이렇게 하면 어떤 효과가 나오냐면, method Overloading

(정의) 하는 일은 같지만, 처리하는 데이터(아귀먼트 리스트)를

달리하는 기법 

하는 일이 같다 = Method 이름이 같다

처리하는 데이타를 달리하는 기법 = Argument List... 순서 갯수 타입이 다르다.

그러면 질문, 리턴 타입은 같아야 할까? 달라야 할까?

리턴 타입은 "can diffier...." 다를 수 있다. 즉 달라도 되고, 다르지 않아도 된다.!! 시험에서 메소드 오버로딩이 나올 때

규칙

1) 메소드 이름은 반드시 (동일)같아야 한다.
2) 인자값은 반드시 달라야 함
3) 리턴 타입은 상관없다 -- 중요!!

 

혹 이름을 비슷하면서 다르게 해도 일관적인 규칙을 해서 

가독성을 잃지 않고, 스펙스틱한 장점도 살릴 수 있어.

오버로딩 느낌 + By00으로 두 가지 장점을 살려볼 수 있어!





-----

접근 지정자(Access Modifier)

말 그대로 접근을 허용하는 범위를 키워드로 지정합니다.

private : 같은 클래스에서만 접근을 허용한다.

[default] (접근 지정자를 아무 것도 안붙이는 경우) = 같은 폴더(패키지) 안에서만 접근 허용

protected : 1) 같은 폴더 안에서만 접근 허용

​					 2) 두 개의 클래스가 상속관계시 public과 동일한 접근 범위를 가진다.

public : 어디서든 접근 허용

```
```

Parent 클래스를 만들고

publicTest, protectedTest, defaultTest, privateTest

네 개의 필드가 있는데

각각 필드명에 맞는 접근 지정자로 만들었다.

이 때 자식 클래스를 만들어보자. 클래스 이름은 Child로 하겠다.

상속 관계로 만든 후, 어떤 접근 지정자까지 접근할 수 있을까?

public과 protected 접근 가능!



자식 클래스로 만들려면

클래스 선언부에 extends 000 으로 해야 된다.

자식에서 부모 필드와 메소드를 사용할 수 있다.

is not visible = 접근이 안된다. 부모 클래스에 (메모리에) 올려져 있기는 한데, 접근 안돼!!





---

상속? "부모가 가진 모든 것을 자식에게 물려주는 것"

소프트웨어에서는 이렇게 정의하면 안된다.

왜? 부모 자식에게 물려주는데, 만약 자식이 자식의 자식에게 상속을 해준다면 무의미하다(?) 프로그래머는 끝단의 단말모드로 사용한다.



내려갈 수록 파워풀한 모드가 되어야 한다.

즉, 소프트웨어 세계에서는 부모가 가진 모든 것을 자식에게 물려주는데, 반드시 하나가 추가되어야 한다. 자식은 자신만의 멤버를 추가해야 한다.

자식에게 내려갈수록 멤버가 많아진다. 메소드가 많아진다.

훨씬 더 powerful해져서(더 구체화된다.) 이것을 사용한다.

올라갈수록 추상화(일반화) 내려갈수록 구체화(스펙스틱)!





object는 필드X, 11메소드

equals와 toString 2개 메소드는 꼭 알아야 돼!!!

toString: 현존하는 주소값을 toString으로 리턴해준다.

EX) MyDate md=new Maydate();

md.00 -> 주소값이 나왔는데, 주소값이 문자로 출력되는 이유가

toString이 생략되어 있어서야!!



equals : 어떤 객체가 다른 객체와 같은지 다른지를 boolean으로 분별해준다.

EX). Person  a=new Person  ();

​		Person  b=new Person  ();

a.equals(b) -> false(다를 때)

같다 === 주소값이 동일하면 같은 객체를 가리킴

주소값을 비교해서 같은 값인지 분별할 때 쓰는게 equals다.



----

추상화 

1. 서로 관련성이 없는 다양한 클래스들에서 공통적인 성질을 추출한다. 이 공통적인 성질을 일반적인 성질로 가지는 모듈을 하나 지정한다.
   -> 이 단계만 하면 문제가 발생할 수 있어 2번을 검사해야돼!!
2. is a relation? 이게 되는지 확인해보아야 돼~~ 예를 들어, 관리자는 고용인이다? 엔지니어는 고용인이다? 비서는 고용인이다? 이것이 되어야만, 상속을 해주는거야!!

부모클래스 parent, super클래스

자식 클래스 Child, sub클래스

자식 클래스는 확장되기에 상속을 extends로 연결한다.







기본생성자가 부모 클래스에 필요한 이유????

에러나는 지점 : 자식 클래스 생성자에서 나고 있어.

생성자는 무엇과 연결되는 알고리즘? 

(객체가 호출될 때 생성자)객체 생성이니까 생성자다, 자식이 만들어질 때 에러가 무조건 난다. 

"자식이 생성될 때 Error"-> 자식이 생성될 때, 부모 생성이 먼저 진행된다. 그런데, 부모 생성이 무조건 먼저 진행된다. 부모가 디폴트로 만들어졌는데, 자식이 생성될 때 에러가 나는데, 이 때 메모리가 어떻게 되는지 알아야 한다.  



메모리

stack     			heap

변수 공간			매니저 객체가 올라간다(이 때 부모가 먼저 만들어져야 한다. 부모의 맴버 name, birthDate, salary가 기본값으로 세팅돼.. 객체가 디폴트로 만들어야 하는데 부모 디폴트 생성자가 없으면 에러가 날 수 밖에없다.)

부모 객체 밑에 디폴트로 만들어지면, 자식 객체가 밑에 추가돼!

자식이 부모에 추가해서 한몸이 돼~ 그래서 디폴트로 부모가 있어야 자녀가 붙어서 한 몸으로 객체가 생성되는거야!!!!





































